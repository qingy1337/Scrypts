Q2

```Python3
class Solution:
    def same(self, a, b):
        if a[0] == b[0] and a[1] == b[1]:
            return True
        else:
            return False

    def is_valid_rectangle(self, a, b, c, d, points):
        x_coords = [a[0], b[0], c[0], d[0]]
        y_coords = [a[1], b[1], c[1], d[1]]
        
        if len(set(x_coords)) != 2 or len(set(y_coords)) != 2:
            return False
        
        min_x = min(x_coords)
        max_x = max(x_coords)
        min_y = min(y_coords)
        max_y = max(y_coords)
    
        for point in points:
            x, y = point
            if min_x <= x <= max_x and min_y <= y <= max_y:
                if point not in [a, b, c, d]:
                    return False
        
        width = max_x - min_x
        height = max_y - min_y
        area = width * height
        
        return area

    def maxRectangleArea(self,points):
        max_area = -1
        for a in points:
            for b in points:
                if self.same(a,b):
                    continue
                for c in points:
                    if self.same(a,b) or self.same(a,c):
                        continue
                    for d in points:
                        bruh = set(list(map(lambda x: tuple(x),[a, b, c, d])))
                        if len(bruh) < 4: continue
                        result = self.is_valid_rectangle(a,b,c,d, points)
                        # print("Got",result,"for",a,b,c,d,"and",points)
                        # print(str(type(result)))
                        if result != False:
                            max_area = max(max_area, result)
        return max_area
```

Q3
```Python3
class Solution:
    def maxSubarraySum(self,nums, k):
        n = len(nums)
        if n == 0:
            return 0
        
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i + 1] = prefix[i] + nums[i]
        
        min_prefix = [float('inf')] * k
        min_prefix[0] = 0
        
        max_sum = float('-inf')
        
        for j in range(n):
            r = (j + 1) % k
            if min_prefix[r] != float('inf'):
                current_sum = prefix[j + 1] - min_prefix[r]
                if current_sum > max_sum:
                    max_sum = current_sum
            if prefix[j + 1] < min_prefix[r]:
                min_prefix[r] = prefix[j + 1]
        
        return max_sum
```
